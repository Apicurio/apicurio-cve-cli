package acveh

import (
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/SafarMirek/apicurio-cve-helper/pkg/acveh/rhp"
	"github.com/SafarMirek/apicurio-cve-helper/pkg/acveh/sbom"
	"github.com/andygrunwald/go-jira"
	version "github.com/knqyf263/go-rpm-version"
)

type QueryResult struct {
	Issues []IssueResult
}

type IssueResult struct {
	Key         string
	Summary     string
	Priority    string
	Cves        []CVEResult
	CanBeClosed bool // Issue can be closed if all cves are solved
}

type CVEResult struct {
	Name           string
	ThreatSeverity string
	Solved         bool // Is CVE solved for image (cve is solved if there is no package that is affected, included and not solved)
	Packages       []PackageResult
}

type PackageResult struct {
	PackageName string
	Status      string
	Solved      bool // Is package fix in image
	Affected    bool // Is RHEL 8 affected by the cve
	Included    bool // Is package included in image
}

func (result *QueryResult) Print() {
	for _, issueResult := range result.Issues {
		fmt.Println("======================================")
		if issueResult.CanBeClosed {
			fmt.Println("CAN BE CLOSED!")
		}
		fmt.Printf("%s: %+v\n", issueResult.Key, issueResult.Summary)
		fmt.Printf("Priority: %s\n", issueResult.Priority)
		for _, cveResult := range issueResult.Cves {
			fmt.Printf("------------- %s -------------\n", cveResult.Name)
			fmt.Printf("ThreatSeverity: %s\n", cveResult.ThreatSeverity)
			fmt.Printf("Solved: %t\n", cveResult.Solved)
			fmt.Printf("Affected Packages on RHEL 8:\n")
			for _, packageResult := range cveResult.Packages {
				fmt.Printf("- %s: %s", packageResult.PackageName, packageResult.Status)
				if !packageResult.Included {
					fmt.Printf(" (not found in SBom)")
				} else if packageResult.Solved {
					fmt.Printf(" (included in image)")
				}
				fmt.Println()
			}
		}
	}
}

func GetCVEIssues(sBom *sbom.SBom) (*QueryResult, error) {
	tp := jira.BearerAuthTransport{
		Token: os.Getenv("JIRA_TOKEN"),
	}

	jiraClient, _ := jira.NewClient(tp.Client(), "https://issues.redhat.com/")

	issues, _, err := jiraClient.Issue.Search("project='MGDSR' AND summary~'CVE-*'", nil)

	if err != nil {
		fmt.Printf("err: %v\n", err)
		return nil, err
	}

	issueResults := make([]IssueResult, 0)

	for _, issue := range issues {
		if issue.Fields.Status.Name == "Closed" {
			continue
		}
		issueResult := IssueResult{
			Key:         issue.Key,
			Summary:     issue.Fields.Summary,
			Priority:    issue.Fields.Priority.Name,
			Cves:        make([]CVEResult, 0),
			CanBeClosed: true,
		}
		cves := extractCVEsFromSummary(issue.Fields.Summary)
		for _, cveName := range cves {
			cveResult := CVEResult{
				Name:           cveName,
				ThreatSeverity: "Unknown",
				Solved:         true,
				Packages:       make([]PackageResult, 0),
			}
			cveStatus, err := rhp.GetCVEStatus(cveName)
			if err != nil {
				cveResult.Solved = false
				issueResult.Cves = append(issueResult.Cves, cveResult)
				continue
			}
			cveResult.ThreatSeverity = cveStatus.ThreatSeverity

			for _, affectedRelease := range cveStatus.AffectedRelease {
				if affectedRelease.ProductName == "Red Hat Enterprise Linux 8" {
					packageName := strings.Split(affectedRelease.Package, ":")[0]
					fixVersion := strings.Split(affectedRelease.Package, ":")[1]
					replaceNumsAtEndRegex := regexp.MustCompile(`-[0-9]+$`)
					packageName = replaceNumsAtEndRegex.ReplaceAllString(packageName, "")

					packageResult := PackageResult{
						PackageName: packageName,
						Status:      "Fixed",
						Affected:    true,
						Solved:      true,
						Included:    true,
					}

					bomPackage := sBom.FindPackage(packageName)
					if bomPackage != nil {
						v1 := version.NewVersion(fixVersion)
						v2 := version.NewVersion(bomPackage.Version)

						if v2.LessThan(v1) {
							packageResult.Solved = false
							cveResult.Solved = false
							issueResult.CanBeClosed = false
						}
					} else {
						packageResult.Included = false
					}
					cveResult.Packages = append(cveResult.Packages, packageResult)
				}
			}

			for _, packageState := range cveStatus.PackageState {
				if packageState.ProductName == "Red Hat Enterprise Linux 8" {
					packageResult := PackageResult{
						PackageName: packageState.PackageName,
						Status:      packageState.FixState,
						Affected:    packageState.FixState != "Not Affected",
						Solved:      false,
						Included:    false,
					}
					if sBom != nil {
						if sBom.FindPackage(packageState.PackageName) != nil {
							packageResult.Included = true
							if packageResult.Affected {
								cveResult.Solved = false
								issueResult.CanBeClosed = false
							}
						}
					}
					cveResult.Packages = append(cveResult.Packages, packageResult)
				}
			}
			issueResult.Cves = append(issueResult.Cves, cveResult)
		}
		issueResults = append(issueResults, issueResult)
	}
	return &QueryResult{Issues: issueResults}, nil
}

func extractCVEsFromSummary(summary string) []string {
	re := regexp.MustCompile(`CVE-[0-9]*-[0-9]*`)
	return re.FindAllString(summary, -1)
}
